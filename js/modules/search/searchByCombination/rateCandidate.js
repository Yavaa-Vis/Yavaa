"use strict";
/**
 * rate the given mappedCandidate with respect to the complete region
 * rating has the following factors:
 * - support: number of columns covered by the mappedCandidate
 * - coverage: percentage of values covered within the matching columns
 * - excess: dimensions in the mappedCandidate, that match no column in the region
 *
 * input:
 *    region:      [ ... columns ],
 *    candDimCount Number
 *    mappedCand:  [ ... columns ],
 *    overlap:     [ ... filter ]
 *
 * overlap as generated by getIntersection()
 *
 *
 * output:
 *    [ coverage, excess ]
 *
 *    coverage: Number
 *    excess: Number
 *
 * column
 * {
 *    "concept":        String,
 *    "minValue":       Number || null,
 *    "maxValue":       Number || null,
 *    "isMeas":         Boolean,
 *    "colEnums":       Array[String] || null,
 *    "totalEnumCount": Number,
 *    "order":          Number                    // just for mappedCandidates
 * }
 */
define( [], function(){

  return function rateCandidate( region, candDimCount, mappedCand, overlap ) {

    // compute rating for each column
    let coverages = [],
        support = region.length,
        mappedDimCount = 0;
    for( let i=0; i<region.length; i++ ) {

      // columns, that could not be matched
      if( !(overlap[i] instanceof Object) ) {
        support -= 1;
        continue;
      }

      // we can not match measurements to dimensions
      if( mappedCand[i]                             // the column exists in the mappedCandidate
          && mappedCand[i].isMeas                   // and is a measurement
          && (region[i].isMeas === false)) {        // the region col is a dimension, though

        // short-circuit
        return [0, 0];

      }

      // count mapped dimensions
      if( mappedCand[i].isMeas === false ){
        mappedDimCount += 1;
      }

      // only compute coverage for dimensions
      if( mappedCand[i].isMeas ) {
        continue;
      }

      // by type
      if( ('totalEnumCount' in mappedCand[i]) && (mappedCand[i].totalEnumCount !== null) ) {

        // enum type - just one list

        // if overlap is empty, we can short-circuit
        if( overlap[i].values.length < 1 ) {
          return [ 0, 0 ];
        }

        if( ('colEnums' in region[i])
            && (region[i].colEnums.length > 0)
            && !region[i].negate ) {

          // finite region
          const regionCount  = region[i].colEnums.length,
                overlapCount = overlap[i].values.length;
          coverages.push( overlapCount / regionCount );


        } else {

          // infinite region
          coverages.push( 1 - ( 1 / (overlap[i].values.length + 1) ) );

        }

      } else {

        // range type - may be multiple lists

        if( (region[i].minValue == null) || (region[i].maxValue == null) ) {

          // infinite region: use width of overlap

          let overlapWidth = (overlap[i].maxValue - overlap[i].minValue);
          if( overlapWidth ) {
            coverages.push( 1 - ( 1 / overlapWidth ) );
          } else {
            coverages.push( 0 );
            break;
          }

        } else {

          // finite region
          let overlapWidth = overlap[i].maxValue - overlap[i].minValue,
              regionWidth  = region[i].maxValue - region[i].minValue;

          // regionWidth might be zero, when we are searching for a single value
          // in that case, every dataset complies completely at this point and we do not need a factor
          if( regionWidth != 0 ) {
            coverages.push( overlapWidth / regionWidth );
          }

        }

      }

    }

    // combine coverages
    const coverage = coverages.reduce( ( total, el ) => { return total * el }, 1 );
    if( Number.isNaN( coverage ) ) {
      throw new Error( 'Could not compute coverage-rating!' );
    }

    // excess columns
    const excess = 1 - (candDimCount - mappedDimCount) / candDimCount;

    // relative support
    support = support / region.length;

    // final rating
    return [ coverage * support, excess ];

  };

});